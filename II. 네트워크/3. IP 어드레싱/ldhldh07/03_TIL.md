# IP 어드레싱

## 3계층의 역할과 개요

### 네트워크

#### 계층의 상하관계

상위 계층은 하위 계층을 생각하지 않는다

하위 계층은 상위 계층을 위해 일한다

#### 세그먼트

라우터와 라우터 간의 범위

2계층 : 세그먼트 내에서 송수신을 하는 것

3계층 : 네트워크 간에서의 데이터 송수신을 하는 것 

#### 네트워크 

세그먼트라는 말은 1계층과 2계층에서 사용하는 말이고 3계층에서는 이것과 같은 범위를 가리켜서 네트워크라고 한다

넒은 의미

- 무언가와 무언가가 그물망으로 연결되어서 무언가를 운반하는 것

좁은 의미

- 세그먼트랑 동의어
- 라우터와 라우터로 분배된 컴퓨터 그룹

### 인터넷 작업

네트워크 내의 인접기기끼리는 2계층에 의해 연결되어 있음

- 멀티액세스 네트워크 혹은 포인트 투 포인트 네트워크의 형태로 컴퓨터가 연결되어 있음
- 1계층에서 신호를 전달하고 2계층에서 그것을 제어함으로써 데이터를 송수신할 수 있는 상태가 되는 것

- 네트워크 내라면 2계층까지만으로도 데이터 송수신이 가능

2계층까지의 기능만으로는 큰 네트워크를 구성할 수가 없음

- 이더넷으로 허브나 스위치를 사용하면 어느 정도 규모는 만들 수 있지만, 여러 가지 걸림돌이 생김

- 허브를 사용한 경우
  - 송신측이 보낸 신호는 허브에 의해 연결되어 있는 모든 기기에 도달함
- 스위치를 사용한 경우
  - 브로드캐스트를 제어하지 않는다는 문제는 해결되지 않음
    - 브로드캐스트를 송신하면 브로드캐스트가 도달하는 범위의 모든 컴퓨터가 그것을 수신해서 자기와 관계가 있는지 없는지를 확인해야 함
    - 그만큼 컴퓨터의 처리가 증가함
    - 대수가 늘어나면 늘어날수록 브로드캐스트의 총 수도 늘어나 확인하는 처리가 많아짐

라우터를 넘어서는 브로드캐스트는 송신되지 않는다

- 1개의 큰 네트워크를 복수의 네트워크로 분할함으로써 브로드캐스트가 도달하는 범위를 제한할 수 있다
- 네트워크를 나누니까 브로드캐스트가 송신되는 양이 줄음

네트워큳와 네트워크 사이에서 어떻게 데이터를 송수신할지

인터넷 작업

- 네트워크 간에서의 데이터 송수신
- 인터넷이라고도 함
- 3계층은 인터넷 작업을 수행하는 것이 그 역할
- 인터넷 작업에 의해 떨어진 위치에 있는 컴퓨터끼리 데이터 통신이 가능



## 인터넷 프로토콜

### 3계층의 역할과 IP

#### 어드레싱

2계층 이더넷

- 어드레스로서 MAC 주소를 사용

3계층

-  MAC 주소를 사용하지 않음
-  MAC 주소는 장소를 특정할 수 없는 주소이기 때문이다
   - 제조업체 번호와 제조업체가 붙인 번호로 구성

3계층을 위한 주소

- 2계층의 세그먼트 내에서의 데이터 송수신에서는 MAC 주소로도 충분
  - 컴퓨터의 수가 적음

- 3계층처럼 네트워크를 가로질러서 다른 네트워크에 네이터를 전송하게 되면 컴퓨터의 수도 많아짐
- 어디라는 정보가 필요함

2계층과 3계층에서 2개의 주소를 사용함

- 물리 주소
  - 2계층에서 사용하는 주소
  - MAC 주소
  - 위치 정보가 포함되어 있지 않음
- 논리 주소
  - 위치 정보가 포함되어 있음
    - 위치정보 : 어디에 네트워크에 있는 어느 컴퓨터라는 정보의 조합으로 실현됨
  - 형태
    - 주소
    - 전화번호
    - 우편번호

#### 라우팅

경로 선택

수신처까지 어떤 경로로 갈 지를 결정

- 복수의 네트워크가 연결되어 있는 상태에서 전달

- 전달하고 싶은 수신처가 여러개의 네트워크를 경유해야 도달하는 곳에 있는 경우 어느 네트워크를 경유해서 갈지를 결정

- 예) 수신처가 X라고 하면 A라는 네트워크를 경우해서 다음에 B라는 네트워크를 지나고 이어서 C라는 네트워크를 경우해서 X까지 간다고 결정해둠

라우팅 

- 경유하는 네트워크를 결정하는 것

- 라우터: 라우팅을 행하는 기기

- 패킷 교환기가 수신처에 연결되어 있는 회선을 선택해서 거기로 패킷을 송신하는 것도 라우팅
  - 회선 : 네트워크
- 각각의 라우터가 수신처에 연결되어 있는 네트워크를 선택해서 거기로 보내는 것

### 인터넷 프로토콜

#### IP(Internet Protocol)

어드레싱과 라우팅에 의해 인터넷 작업을 수행하기 위한 프로토콜

TCP/IP 프로토콜에서 반드시 IP를 사용함

인터넷 작업 프로토콜

2가지 버전

- IP버전4(IP version4, IPv4)
- IP버전5(IP version6, IPv6)

- 현재 일반적으로 사용되고 있는 것은 옛 버전인 IPv4
- 두 버전 사이에는 호환성이 없음
  - IPv4만 사용하는 컴퓨터에는 IPv6를 사용하는 컴퓨터와 데이터 송수신을 못한다
- 둘 다 사용할 수 있는 컴퓨터도 있음
  - 최근의 OS
- IPv6은 앞으로 보급될 버전인데 지금은 아직 구 버전인 IPv4쪽이 더 우세하다
  - 버전을 변경하게 되면 인터넷의 모든 기기가 거기에 대응해야 해서 변경이 간단하지 않다

#### IP데이터그램

데이터 즉, 3계층 PDU 에 IP헤더가 붙은 상태의 PDU

IP 헤더와 IP 데이터 그램의 캡슐화

##### IP헤더

- 송신처와 수신처의 IP 주소
- IP주소
  - 프로토콜에서 정해진 논리 주소
  - IP에서는 IP주소를 통해 수신처와 송신처를 정함

IP 헤더 20바이트 + α(옵션) + 페이로드(상위 4계층 PDU 등이 들어간다.) 0~8 키로바이트

|      |                   |      |                                        |
| ---- | ----------------- | ---- | -------------------------------------- |
| 1    | 버전              | 4    | IP의 버전                              |
| 2    | 헤더 길이         | 4    | IP 헤더의 길이                         |
| 3    | 서비스 타입       | 8    | 패킷의 우선도/중요도                   |
| 4    | 데이터 길이       | 16   | IP헤더와 페이로드를 합친 길이          |
| 5    | ID                | 16   | 데이터그램의 식별번호                  |
| 6    | 플래그            | 3    | 데이터그램을 분할했는지 아닌지 판별    |
| 7    | 플래그먼트 오프셋 | 13   | 분할한 경우 본래대로 되돌릴 때 사용    |
| 8    | TTL               | 8    | 패킷의 생존시간                        |
| 9    | 프로토콜          | 8    | 상위 프로토콜 지정                     |
| 10   | 헤더 체크섬       | 16   | IP 헤더의 에러 체크용 코드             |
| 11   | 송신처 IP 주소    | 32   | 송신처의 논리 주소                     |
| 12   | 수신처 IP 주소    | 32   | 수신처의 논리 주소                     |
| (13) | 옵션              | n    | 특별한 설정을 할 때 사용. 없어도 된다. |



## IP 주소

### IP 주소의 특징

IP주소: IP에서 정해진 어드레스

#### 계층형 주소

- IP 주소 같은 논리 주소의 특징
- 논리 주소는 그 주소 자체에 의미가 있다
- 어디에 있는, 어느 컴퓨터라는 정보를 A에 있다, A안에 있는 B에 있다, C라는 컴퓨터와 같이 더욱 세분할수 있다

- 집주소도 계층형 주소
  - '서울'의 ' 금천구'의 '가산디지털2로'의 '123'

#### 네트워크 관리자가 컴퓨터에 할당

MAC주소

- IEEE가 붙인 벤더코드와 벤다가 붙인 할당코드로 이루어져 있어서 사용하는 쪽에서 변경이 불가능
- 인터페이스에 포함되어 있으니까 어디에 있어도 같은 주소

논리주소

- 그 네트워크의 관리자가 필요에 따라 자유롭게 붙일 수 있음

- 인터페이스가 어느 것이든 상관 없이 네트워크에 접속할 때마다 붙임
  - 인터페이스가 고장나서 다른 인터페이스로 교환했다고 하더라도 바뀌지 않음
- 소속된 네트워크가 바뀐 경우 논리 주소도 바뀌게 됨

#### 유니캐스트 주소의 논리 주소 

네트워크를 표시하는 번호는 접속되어 있는 모든 네트워크에서 유일할 필요가 있다

- 접속되어 있지 않으면 유일하지 않아도 된다
- 독립한 네트워크끼리라면 상관없다

컴퓨터 번호는 소속된 네트워크 내에서 유일해야 함

- 다른 네트워크에 소속되어 있으면 같은 번호여도 된다

네트워크 번호 + 컴퓨터 번호라는 형태가 되면 반드시 유일하게 됨

### IP 주소

IPv4에서 32비트

IPv6에서 128비트

32비트, 옥텟마다 10진수로 변환해서 단락에 점을 찍어 표기한다

- 비트(2진수)로 기술
  - 11000000101010000010101000000001
- 옥텟으로 분할
  - 11000000 | 10101000 | 00101010 | 00000001
- 옥텟을 10진수로
  - 192  | 168 | 42 | 1
- 옥텟 단락에 점을 찍는다
  - 192.168.42.1
- 왼쪽부터 제 1옥텟, 제2옥텟···이라고 부른다
- 4개의 옥텟, 다시 말해 32비트로 '네트워크 번호'와 '컴퓨터 번호'를 나타냄
- 클래스라는 것으로 어디가 네트워크 번호고 어디가 컴퓨터인지 정해짐

### IP 주소의 클래스

#### ICANN

IP주소를 유일하게 관리하기 위한 단체

IP 주소를 실제로 사용하는 인터넷 사업자나 기업 등에 할당

IP 주소를 가지고 있다가 기업이나 인터넷 사업자에게 대출한다고 생각하면 됨

#### 클래스와 규모

ICANN이 대출을 할 때 그 할당된 조직의 규모에 따라 대출 IP 주소의 범위를 변경함

##### 클래스풀 어드레싱

클래스로 나누어 IP 주소를 할당하는 방식

A~E의 5개로 나누고 그 범위의 주소를 할당

| 클래스 | 제1옥텟    | 제2옥텟    | 제3옥텟    | 제4옥텟  |
| ------ | ---------- | ---------- | ---------- | -------- |
| A      | 0xxxxxxx \ | xxxxxxxx   | xxxxxxxx   | xxxxxxxx |
| B      | 10xxxxxx   | xxxxxxxx \ | xxxxxxxx   | xxxxxxxx |
| C      | 110xxxxx   | xxxxxxxx   | xxxxxxxx \ | xxxxxxxx |
| D      | 1110xxxx   | xxxxxxxx   | xxxxxxxx   | xxxxxxxx |
| E      | 1111xxxx   | xxxxxxxx   | xxxxxxxx   | xxxxxxxx |

- 클래스 A는 최초의 9비트, 즉 최초의 옥텟이 네트워크 번호이고 나머지가 컴퓨터 번호

- 클래스 B는 16비트와 16비트

- 클래스 C는 24비트와 8비트

- 클래스 D와 클래스 E는 특별한 주소라 보통은 할당하지 않음

- 클래스 D하고 E의 IP 주소를 요구하는 조직이 있어도 이 주소는 사용되지 않음

최초 옥텟의 맨 앞 몇 비트로 판별

- 예) IP주소 32비트의 1비트와 2비트가 '1', '0'이라면 그건 클래스 B

네트워크 번호 부분의 비트수가 적으면 그만큼 컴퓨터 번호 부분의 비트수가 많음

- 비트수가 많다는 건 그만큼 사용할 수 있는 번호가 많아진다는 의미
- 많은 컴퓨터를 소유하는 네트워크가 될 수 있다
- 예) 클래스 A라면 네트워크 번호 8비트, 컴퓨터 번호 24비트
  - 2의 24승 16,777,216개의 컴퓨터를 가질 수 있다

### 예약 완료 주소

네트워크 번호가 몇 비트인지는 할당된 클래스에 따라서 정해지는데, ICANN이 할당하는 것은 이 네트워크 번호까지

컴퓨터 번호를 호스트 변호라고 함

호스트 번호는 그 네트워크의 관리자가 마음대로 정하는 것

- 예) 네트워크 번호가 '서울시'라고 정하면 '서울시'의 관리자가 '금천구 가산디지털2로 123 월드메르디앙벤처센터 2차 10층'이라고 정함

호스트 번호 중에 특별한 의미를 가지기 때문에 실제의 컴퓨터에 할당해서는 안 되는 주소

- 네트워크 주소
  - 호스트 번호의 비트가 모두 0이 되는 주소
  - 예) 192.169.10.0
  - 그 네트워크 자체를 표시할 때 사용
- 브로드캐스트 주소
  - 호스트 번호의 비트가 모두 1이 되는 주소
  - 예) 192.169.10.255
  - '전체가 수신'하는 주소

## 서브네팅

### 네트워크를 분할한다

서브넷이라고도 함

IP 주소는 계층형이며 커다란 네트워크 안에 작은 네트워크를 만들 수 있다

이렇게 분할된 작은 네트워크를 서브네트워크 또는 서브넷이라고 함

호스트 번호의 일부를 줄여서 서브넷 번호를 만든다

- 서브넷으로 분할할 때는 서브네트워크를 나타내는 번호인 서브넷 번호가 필요함

- IP 주소는 32비트로 고정되어 있어서 새롭게 서브넷 번호를 추가하는 것은 불가능
- 호스트 번호의 비트를 서브넷 번호와 호스트 번호로 분할

- 예) 172.16.0.0에서 호스트 번호 16비트를 서브넷 번호 6비트와 호스트 번호 10비트로 분할함

  - 서브네트워크 1번의 호스트 번호 1번 컴퓨터의 IP 주소: 172.16.4.1
  - 서브넷화전 : 172.16.4.1
  - 서브넷화후: 10101100 00010000 /000001/00 00000001
    - 네트워크 번호 : 10101100 00010000
    - 서브넷 번호: 000001
    - 호스트 번호: 00 00000001

  - 4번 서브넷의 1번 컴퓨터로 보이지만 아니다
    - 10진수 표기법과 헷갈려서 그런 것이고 IP 주소는 비트다

### 서브넷 마스크

호스트 번호는 그 네트워크 관리자가 결정

서브넷 번호 부분도 원래는 호스트 번호 부분에서 가져다 씀

ICANN과 상관없이 그 네트워크 관리자가 마음대로 정할 수 있음

서브넷은 그 네트워크의 내부에서만 유효하다

- 네트워크 외부에서는 네트워크A의 서브넷1이나 서브넷2나 같은 네트워크A에 있기 떄문에 일일이 내부까지 몰라도 됨
- 인천광역시가 4개의 구로 분할되어 있다 해도 외부에서 보면 같은 인천 광역시

서브네팅(Subnetting)

- 이렇게 서브넷화하는 것

예) 클래스C 네트워크

- 192.168.100.0

- 서브넷의 숫자를 크게 하면 각 서브넷의 호스트 수는 감소

- 서브넷 부분에 비트수를 뺏기니까 서브넷 마다의 호스트 수가 줄어든다

  | 제1옥텟  | 제2옥텟  | 제3옥텟  | 서브넷부분 | 호스트부분 | 서브넷의 최대 수 | 서브넷마다 호스트 수 |
  | -------- | -------- | -------- | ---------- | ---------- | ---------------- | -------------------- |
  | 11000000 | 10101000 | 01100100 | -          | 00000000   | 없음             | 254대                |
  | 11000000 | 10101000 | 01100100 | 0          | 0000000    | 2개              | 126대                |
  | 11000000 | 10101000 | 01100100 | 00         | 000000     | 4개              | 62대                 |
  | 11000000 | 10101000 | 01100100 | 000        | 00000      | 8개              | 30대                 |
  | 11000000 | 10101000 | 01100100 | 0000       | 0000       | 16개             | 14대                 |
  | 11000000 | 10101000 | 01100100 | 00000      | 000        | 32개             | 6대                  |
  | 11000000 | 10101000 | 01100100 | 000000     | 00         | 64개             | 2대                  |
  | 11000000 | 10101000 | 01100100 | 0000000    | 0          | 128개            | 0대                  |
  | 11000000 | 10101000 | 01100100 | 00000000   | -          | 256개            | 0대                  |

  - 서브넷이 10개 필요한 경우 : 서브넷 부분 4비트, 호스트 부분 4비트가 되기 떄문에 서브넷마다 최대 14대
  - 호스트가 각 서브넷에 50대가 있을 경우 : 서브넷 부분 2비트, 호스트 부분 6비트가 되기 떄문에 서브넷의 수는 최대 4대


컴퓨터가 어느 네트워크에 소속되어 있는지 알아야 함

- IP 주소의 어디까지인지가 네트워크 주소인지 모르면 그것이 자신과 동일한 네트워크인지 아니면 다른 네트워크인지 모르게 됨
- 클래스를 알면 어디까지가 네트워크 번호인지는 알 수 있지만, 어디까지가 서브넷 번호인지 모름

서브넷마스크(Subnetmask)

- 비트열과 IP 주소와 동시에 표기
- IP 주소 중에 어디까지가 서브넷 번호인지를 나타냄
- IP 주소오 ㅏ같은 342비트
- 네트워크 번호 · 서브넷 번호의 비트를 모드 1, 호스트 번호를 0으로 한것
- 서브넷마스크의 비트가 1인 부분이 네트워크 번호
- IP주소와 서브넷마스크는 반드시 세트로 기술
- 예) 11111111 11111111 11111100 00000000

## 클래스리스 어드레싱

### 클래스풀과 클래스리스

지금은 클래스풀 어드레싱은 사용되지 않음

- 인터넷 보급에 따라 IP주소를 필요로 하는 조직이 많아져서 클래스풀 어드레싱으로는 문제가 있음
  - 3개의 클래스 A·B·C라는 대략적인 구분밖에 없음
  - 그 구분에 딱 맞지 않으면 낭비가 많아짐
  - 사용되지 않는 IP 주소가 증가

그래서 클래스리스 어드레싱(Classless Addressing)

### 클래스리스 어드레싱

클래스라는 구분을 없앤 어드레싱

- 클래스에 따른 고정된 할당을 하지 않고 자유롭게 할당할 수 있게 됨

필요에 따른 비트 수로 정함

예) 네트워크 번호가 18비트 필요하고 그 번호를 '1010 0000 0000 0001 01'로 한다는 식으로 정함

필요한 IP주소로부터 정함

예) 네트워크 번호가 18비트라면 호스트 부분에 사용할 수 있는 것은 32-18로 14 비트, 약 16,000개가 사용할 수 있는 IP 주소가 됨

슈퍼넷

- 원래는 클래스에 의한 할당 클래스풀 어드레싱을 해왔기 때문에 그 클래스를 통합해서 1개로 하는 것도 가능함
- 클래스 C의 네트워크를 통합해서 1개의 네트워크로 운영한다
- 2000개의 주소가 필요한 네트워크
  - 클래스C에서는 주소가 부족하다
  - 클래스B에서는 주소가 너무 많다
  - 8개의 클래스C를 통합해서 2,048개의 IP 주소를 갖는 네트워크로 만든다
  - 21비트를 네트워크 번호로 한다
  - 192.168.32.0(네트워크 번호 21비트)인 2,048개의 IP 주소를 갖는 슈퍼넷
  - 호스트 번호로 11비트를 사용하면 000 000000000 ~ 111 11111111인 2,048개가 있다

문제점

- 클래스가 없기 때문에 어디까지가 네트워크 번호의 비트인지를 모름

프리픽스 길이(Prefix-Length)

- 네트워크 번호의 길이를 나타나는 값
- 이것을 IP부호랑 같이 씀

- 21비트를 네트워크 번호로 하고 11비트를 호스트 번호로했을때
- 192.168.32.0 / 21
  - 주소 뒤에 슬래시를 넣고 그 뒤에 네트워크 번호 비트수(프리픽스 길이)를 기술한다
- 서브넷마스크의 255.255.248.0과 거의 같은 의미
  - 1111 1111 1111 1111 1111 1000 0000 0000

## DHCP

### 송신처의 IP 주소와 MAC 주소

이더넷을 사용해서 IP데이터그램을 송수신하기 위해서 4개의 주소가 필요

- 수신처 MAC 주소
- 송신처 MAC 주소
  - 송신할 인터페이스의 MAC 주소
- 수신처 IP 주소
- 송신처 IP 주소
  - 송신할 인터페이스에 설정되어 있는 IP 주소 사요ㅕㅇ
    - 정적인 것
      - 수동으로 IP 주소를 설정
    - 동적인 것
      - DHCP(Danamic Host Configuration Protocol)
      - IP 주소가 자동으로 컴퓨터에 설정되는 방법

### DHCP

할당할 IP 주소를 관리하고, 실제로 할당 작업을 수행하는 서버(Server)하고 할당 받는 클라이언트(Client)로 이루어진다

#### DHCP 서버

- DHCP의 서버
- DHCP 서버 소프트웨어라는 전용 소프트웨어를 실행

#### DHCP 클라이언트

- DHCP의 클라이언트
- DHCP 클라이언트 소프트웨어를 실행

클라이언트가 IP 주소를 요청하면 서버가 그에 응해 IP 주소를 할당함

#### IP 주소 풀

- 사전에 관리자가 할당할 주소의 범위
- 이 범위 내의 주소를 호트스에게 할당해도 좋다고 관리자가 결정해줄 필요가 있음
- 예) 192.168.1.0/24라는 네트워크에 있는 호스트에게 주소를 할당
  - 192.168.1.1 ~ 192.168.1.254까지의 주소를 할당해도 좋다고 결정해둠

서버는 IP 주소 풀 중에서 요청한 클라이언트에게 각각 유일한 것이 되도록 주소를 할당

1. 클라이언트가 서버에거 IP 주소 취득요청
2. 서버가 IP 주소 풀에서 사용되고 있지 않은 주소를 선택함
3. 클라이언트에게 IP 주소 할당

관리자가 범위만 정해놓으면 나머지는 서버가 자동적으로 할당

네트워크 관리자는 사전에 IP 주소의 대여 기간을 결정해 놓을 필요가 있다

할당보다는 대여라는 표현이 적절

기간을 설정하는 이유

- 호스트가 이동하거나 고장 난 경우
- 서버는 IP 주소를 할당했기 때문에 IP 주소는 이미 사용되고 있다고 생각함

- 그 컴퓨터에 할당한  IP 주소는 더 이상 사용할 수 없게 됨
- 그래서 대여기간을 설정
- 클라이언트 측이 계속해서 사용하고 싶으면 기간 연장을 신청

#### DHCP 메시지

주소와 옵션 설정 등의 정보를 갖는다

| 이더넷 헤더 | IP 헤더 | UDP 헤더 | DHCP 메시지 |
| ----------- | ------- | -------- | ----------- |

| 옥텟 | 이름                     | 설명                                                         |
| ---- | ------------------------ | ------------------------------------------------------------ |
| 1    | 오퍼레이션 코드          | 클라이언트->서버···1, 서버->클라이언트···2                   |
| 4    | 클라리언트 IP 주소       | 현재의 클라이언트 주소(재 대여 시에만)                       |
| 4    | 할당 IP 주소             | 서버가 할당한 주소                                           |
| 3    | 서버 IP 주소             | 서버 주소                                                    |
| 16   | 클라이언트 하드웨어 주소 | 클라이언트의 MAC 주소                                        |
| 가변 | 옵션                     | 메시지타입과 클라이언트 설정(서브넷마스트 · 디폴트게이트웨이 · DNS 서버 주소 · 대여기간 등) |

DHCP는 IP 주소만이 아니라 다른 네트워크의 설정 정보도 보낼 수 있음

동적 호스트 설정 프로토콜이라고 불림

#### DHCP의 동작

DISCOVER, OFFER, REQUEST, ACK 4 종류의 메시지를 클라이언트와 서버 간에 브로드캐스트를 사용해서 주고받는다

1. 클라이언트는 DHCP DISCOVER 메시지를 브로드캐스트한다

2. DISCOVER를 받은 서버는 할당할 IP 주소를 풀에서 선택해서 그것을 클라이언트에게 브로드캐스트해서 통지한다. (DHCP OFFER)
3. 클라이언트는 OFFER에서 받은 IP 주소로 문제가 없으면 DHCP REQUEST를 서버에 브로드캐스트한다
4. REQUEST를 받은 서버는 문제가 없으면 AHCP ACK를 보낸다.
5. 그 때 서브넷마스크 등 옵션 설정도 ACK에 넣어서 보낸다

송수신은 브로드캐스트를 사용해서 전체 수신으로 보냄

- 컴퓨터가 기동한 시점에서는 클라이언트는 누구에게 메시지를 보내면 좋을지 모르기 때문
- 어느 네트워크에 소속되어 있는지를 모름

## ARP

### 주소해결 프로토콜

- 수신처 MAC 주소
  - 수신처의 IP 주소가 결정된 후에 정해짐
    - ARP(Address Resolution Protocol)
- 송신처 MAC 주소
- 수신처 IP 주소
- 송신처 IP 주소

#### ARP

주소 해결 프로토콜

- 이 IP 주소의 호스트님, 당신의 MAC 주소를 알려주세요라고 질문하는 프로토콜
- 이걸로 'MAC 주소를 모르는' 상태를 '해결'하는 프로토콜

### ARP 테이블과 ARP

데이터를 전송하고 싶은 컴퓨터는 수신처의 IP 주소를 결정하고, 그 후에 수신처 MAC 주소를 알기 위해서 ARP 테이블을 참조

#### ARP 테이블

IP 주소와 MAC 주소의 대응표

IP 주소의 컴퓨터 주소는 이것이다

- 예) 192.168.0.1의 MAC 주소는 00-40-26-f4-1a-02입니다

ARP 테이블의 수신처 IP와 MAC 주소의 대응이 있으면 그 시점에서 수신처 MAC 주소를 알 수 있음

#### ARP 요청

ARP 테이블에 수신처 IP 주소와 MAC 주소의 대응이 없는 경우에는 수신처 MAC 주소를 모름

ARP를 사용해서 묻고 그 결과를 ARP 테이블에 기재

이 알려달라는 동작을 ARP 요청이라고 부름

브로드캐스트로 네트워크 내의 모든 컴퓨터에 송신

#### ARP 응답

알려달라라고  요청받았기 떄문에 자신의 MAC 주소가 이것이라고 응답

ARP 응답을 받은 컴퓨터, 즉 ARP 요청을 송신한 측의 컴퓨터는 ARP의 결과를 ARP 테이블에 기재

수신처의 MAC 주소가 결정됨



#### ARP의 동작

브로드캐스트로 ARP 요청을 보내고 대응하는 컴퓨터만 응답한다

1. 송신을 원하는 컴퓨터는 먼저 자신의 ARP 테이블을 참조한다
2. ARP 테이블에 수신처 IP 주소가 없을 경우 ARP 요청을 브로드캐스트한다
3. ARP 요청의 수신처를 확인하고 자신인 경우에는 응답한다. 그렇지 않은 경우는 파기한다
4. ARP 응답을 받으면 ARP 테이블에 응답 결과를 추가로 기술한다

#### ARP 파기

ARP 테이블에 기재되어 있는 IP 주소와 MAC 주소의 대응은 일정 기간이 지나면 파기됨

수동으로 IP 주소와 MAC 주소의 대응을 ARP 테이블에 설정한다면 사라질 일은 없지만 일반적으로 그렇게 하지는 않는다

인터페이스 고장 등으로 MAC 주소가 변경되어도 대응할 수 있도록 하기 위해

- ARP를 통해서 IP 주소에 대응한 MAC 주소를 받은 후에 인터페이스가 고장난다면 MAC 주소는 변경된다

- IP 주소는 인터페이스가 고장나서 교환해도 변경되지 않는다

- IP는 전 주소 그대로고 MAC 주소는 새로운 값이 되는것

- ARP 테이블에 기재되어 있는 IP 주소와 MAC 주소의 대응은 일치하지 않게 됨

틀린 MAC 주소로 데이터를 보내면 데이터가 도달하지 않게 됨

그래서 ARP 테이블을 파기함

## DNS

### 수신처 IP 주소를 안다

- 수신처 MAC 주소
- 송신처 MAC 주소
- 수신처 IP 주소
  - 가장 간단한 방법
    - 데이터 전송을 원하는 애플리케이션이나 사용자가 수신처의 IP 주소를 알고 있는 경우
    - 숫자를 잘 못외움
  - 도메인 명(Domain Name) 사용
- 송신처 IP 주소

### DNS

도메인 명은 송신할 상대의 컴퓨터 이름

외우기 쉽도록 영문과 숫자로 구성되며 가장 좋은 예는 WWW로 사용되고 있는 http://의 뒤에 오는 문자열

다른 컴퓨터와 구별해야 하기 때문에 유일한 이름이여야 한다

- IP 주소와 마찬가지로 ICANN이 관리

도메인 명으로 송신하고 싶은 상대를 간단하게 기억할 수 있도록 되어 있다

IP 주소를 직접 기억하는 것은 어려우니까 이름을 붙임

문제

- 역시 데이터 통신에는IP 주소가 필요

#### DNS(Domain Name System)

이름과 IP 주소를 대응시킨 시스템

1. 사용자 애플리케이션은 도메인 명으로 수신처를 지정
2. 그 도메인 명에 대응하는 IP 주소를 문의한다
3. DNS 서버는 문의한 도메인 명에 대응한 IP 주소를 데이터베이스에서 찾는다
4. 도메인 명에 대응한 IP 주소를 응답한다

#### DNS 서버

이름과 IP 주소의 대응 데이터베이스를 가지고 있음

DNS 서버에 문의해서 수신처의 IP 주소를 입수

DNS 서버는 각 조직에 1개씩 있고 그 조직의 도메인 명만 관리

다른 조직의 호스트 명과 도메인 명 

- 그 조직의 DNS 서버에 물음

1. 사용자 애플리케이션은 도메인 명으로 수신처를 지정
   - `www.3min.net`와 데이터를 송수힌하고 싶다
2. 그 도메인 명에 대응하는 IP 주소를 문의한다
   - `www.3min.net` IP 주소를 알려줘?
3. 다른 조직의 도메인 명은 그 조직의 서버에 문의한다.
   - 다른 조직의 도메인 명은 그 조직의 서버에 물어보자
4. 도메인 명에 대응한 IP 주소를 입수한다
   - 200.100.10.1이에요
5. 입수한 IP 주소를 DNS 서버 `www.3min.net`에 가르쳐준다

DNS란 전 세계의 도메인 명 · 호스트 명을 관리하는 일종의 분산형 데이터베이스

- 여러 이름의 데이터베이스가 여기저기에 분상되어 있기 때문

### 4개의 주소 · 완결편

송신처의 주소

- MAC 주소는 NIC를 설치하면 자동적으로 알 수 있음

송신처의IP 주소

- 수동 또는 DHCP로 할당 받아서 알 수 있다

수신처 IP 주소

- 사용자 혹은 애플리케이션이 수신처의 도메인 명을 결정하면 DNS로 수신처 IP 주소를 알 수 있다

수신처 MAC 주소

- 수신처 IP 주소를 알면 ARP로 수신처 MAC 주소를 알 수 있다

데이터 전송이 가능해진다

DHCP, ARP, DNS를 사용하여 4개의 주소를 결정한다

1. 자신의 IP 주소는 수동 또는 DHCP에서 할당 받고, MAC 주소는 자동적으로 안다.
2. 사용자 애플리케이션이 수신처의 도메인 명을 결정하면 DNS로 IP 주소를 취득한다
3. IP 주소가 결정된 후 ARP에 의해 MAC 주소를 취득한다
4. 이것으로 송신처, 수신처의MAC 주소, IP주소를 알았기 때문에 데이터 전송이 가능해진다.